import logging
import os
import re

from datetime import datetime
from pathlib import Path
from typing import Optional, TypeVar


FolderCT = TypeVar("FolderCT", bound="FileCleaner")


class FolderCleaner:
    """
    A class for processing folders,  going to use it to load a default time for files in this directory
    """

    def __init__(self, path_entry: Path, root_directory: Path = None, parent: FolderCT = None):

        self.path: Path = path_entry
        self.root_directory: Path = root_directory

        self.folder_time: Optional[datetime] = None
        self.description: Optional[str] = None
        self.parent: Optional[FolderCT] = parent

        self.folder_time = self.get_date_from_path()  # A lot of re stuff, so just cache the value.
        self.description = self.get_description_from_path()

    def _get_date_from_path_name(self, regexp: str,  date_format: str, array_max: int) -> Optional[datetime]:
        re_parse = re.match(regexp, self.path.name)
        if re_parse:
            re_array = re_parse.groups()
            date_string = "".join(re_array[0:array_max])
            try:
                return datetime.strptime(date_string, date_format)
            except ValueError:
                logging.debug(f'Could not convert {date_string} of {self.path.name} to a date')
        return None

    def _get_description_from_path_name(self, regexp: str, array_max: int) -> Optional[str]:
        re_parse = re.match(regexp, self.path.name)
        if re_parse:
            re_array = re_parse.groups()
            return re_array[array_max].rstrip().lstrip()
        return None

    def get_date_from_path(self) -> Optional[datetime]:
        parser_values = [
            ['^([0-9]{8})-([0-9]{6})$', '%Y%m%d%H%M%S', 3],
            ['^([0-9]{4}).([0-9]{2}).([0-9]{2}).*', '%Y%m%d', 3],
            ['^([0-9]{2}).([a-zA-Z]{3}).([0-9]{4}).*', '%d%b%Y', 3],
            ['^([0-9]{4}).([0-9]{2}).+', '%Y%m', 2]
        ]

        if len(self.path.name) == 22 and self.path.name.find(' ') == -1:  # Get rid of garbage first
            return None

        for exp, fmt, index in parser_values:
            folder_date = self._get_date_from_path_name(exp, fmt, index)
            if folder_date:
                return folder_date

        parse_tree = re.match('.*([0-9]{4}).([0-9]{1,2}).([0-9]{1,2})$', str(self.path))
        if parse_tree:
            try:
                return datetime(int(parse_tree.groups()[0]),
                                int(parse_tree.groups()[1]),
                                int(parse_tree.groups()[2]))
            except ValueError:
                pass

        parse_tree = re.match('^([0-9]{4})[A-Za-z].*', str(self.path.name))
        if parse_tree:
            try:
                return datetime(int(parse_tree.groups()[0]), 1, 1)
            except ValueError:
                pass

        parse_tree = re.match('^([0-9]{4})$', str(self.path.name))
        if parse_tree:
            try:
                return datetime(int(parse_tree.groups()[0]), 1, 1)
            except ValueError:
                pass

        # Use the parent date
        parent = self.parent
        while parent:
            if parent.folder_time:
                return self.parent.folder_time
            parent = parent.parent
        return None

    def get_description_from_path(self) -> Optional[str]:
        """
        - pictures/2021/10/11
        - pictures/2014/2014/06/30
        pictures/2004_04_17_Roxy5
        pictures/2016-09-25 Murphys Point
        pictures/2003_10_Sara
        pictures/2016 - Camping
        pictures/Alex's House
        - pictures/2014/2014/06/30/20140630-063739/zCMlYzsaTqyElbmIFHvvLw
        - pictures/2014/2014/06/30/20140630-063736
        pictures/2003_04_06_TriptoFalls
        - pictures/12-Aug-2014

        :return:
        """


        parser_values = [
            '^[0-9]{4}.[0-9]{2}.[0-9]{2}(.+)',
            '^[0-9]{2}.[a-zA-Z]{3}.[0-9]{4}(.+)',
            '^[0-9]{4}.[0-9]{2}(.+)',
            '^[0-9]{4}(.+)',
        ]

        # We have a lot of they were generated by some other import
        if len(self.path.name) == 22 and self.path.name.find(' ') == -1:
            return None
        elif re.match('^[0-9]{8}-[0-9]{6}$', self.path.name):  # Pure Date
            return None
        else:
            try:
                int(self.path.name)
                return None  # Pure date path
            except ValueError:
                pass

        description = None
        matched = False
        for exp in parser_values:
            re_parse = re.match(exp, self.path.name)
            if re_parse:
                description = re_parse.groups()[0]
                matched = True
                break

        if not description and not matched:
            description = self.path.name

        if description:  # Cleanup some junk
            parts = re.match('^([-_ ]*)(.*)', description)
            description = parts.groups()[1]
        return description

    def recursive_description_lookup(self, current_description: str, to_exclude) -> str:
        """
        Recurse your parents to build up path based on descriptive folder names
        :param current_description:  a string with the build up path
        :param to_exclude: an array of path components that we don't want to include in description tree

        :return: a string with the path name based on os.path.sep and the various folder levels
        """
        if self.description:
            if self.description not in to_exclude:
                current_description = f'{os.path.sep}{self.description}{current_description}'
            if self.parent:
                current_description = self.parent.recursive_description_lookup(current_description, to_exclude)
        return current_description
